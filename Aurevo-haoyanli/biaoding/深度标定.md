# MaixSense 深度相机精度校准流程

本文档指导用户如何使用提供的 Python 脚本对 MaixSense 深度相机的深度测量精度进行校准。此校准过程旨在修正相机报告的深度值与真实物理距离之间的系统误差。

整个流程分为两个主要步骤：

1.  **数据采集 (`collect_depth_calibration_data.py`)：** 在不同已知距离处，采集相机报告的深度值。
2.  **模型拟合与参数保存 (`analyze_and_fit_depth_correction.py`)：** 使用采集到的数据拟合一个校正模型，并保存模型参数。

---

## 第1步：采集深度校准数据 (`collect_depth_calibration_data.py`)

此脚本通过网络连接到 MaixSense 相机，实时显示深度图像，并允许用户在不同距离处记录相机报告的深度值和对应的真实物理距离。

### 准备工作

1.  **硬件准备：**
    *   MaixSense 深度相机，已开机并连接到与运行脚本的电脑相同的局域网。
    *   一个**平整、漫反射的平面目标**（例如，一面干净的、无复杂纹理的墙壁）。
    *   **精确的测距工具**（例如，卷尺、激光测距仪）。
2.  **软件准备：**
    *   必要的 Python 库：`opencv-python`, `numpy`, `requests`。可以通过 `pip install opencv-python numpy requests` 安装。
    *   `collect_depth_calibration_data.py` 脚本文件。

### 运行脚本

1.  打开你的终端（命令提示符、PowerShell、Linux/macOS Terminal）。
2.  使用 `cd` 命令导航到 `collect_depth_calibration_data.py` 脚本所在的文件夹。
3.  执行以下命令（根据你的情况修改参数）：

    ```bash
    python collect_depth_calibration_data.py --depth_mode_cam <mode> --output_file <data_file.json> [--host <ip>] [--port <port>] [--center_roi_ratio <ratio>]
    ```

    **参数说明：**

    *   `--depth_mode_cam <mode>`: **(必需)** 指定你希望为哪种相机深度输出模式进行校准。
        *   `0`: 16-bit 深度模式。
        *   `1`: 8-bit 深度模式。
        *(脚本顶部的 `DEPTH_8BIT_DIVISOR_PRE_CORRECTION` 和 `DEPTH_16BIT_SCALE_PRE_CORRECTION` 参数需要根据你的相机特性预先设置好，以得到一个初步的毫米级“报告深度”。特别是，如果你知道16位原始值需要特定转换（例如除以4）才是近似毫米，请修改 `DEPTH_16BIT_SCALE_PRE_CORRECTION` 为相应的乘数，如 `0.25`。)*
    *   `--output_file <data_file.json>`: **(必需)** 指定保存采集到的 `(真实距离, 相机报告深度)` 数据对的JSON文件名。
        *   例如：`my_16bit_depth_data.json` 或 `my_8bit_depth_data.json`。
    *   `--host <ip>`: (可选) 相机的IP地址。默认为 `192.168.233.1`。
    *   `--port <port>`: (可选) 相机的端口。默认为 `80`。
    *   `--center_roi_ratio <ratio>`: (可选) 用于提取平均深度的中心区域 (ROI) 大小比例（相对于图像宽/高）。默认为 `0.2` (即中心20%的区域)。

    **示例命令 (为16位深度模式采集数据)：**
    ```bash
    python collect_depth_calibration_data.py --depth_mode_cam 0 --output_file my_16bit_depth_data.json
    ```

### 操作流程

1.  脚本启动后，会尝试连接并配置相机。成功后，会打印操作指南。
2.  一个名为 "Depth Stream (ROI in Green)" 的 OpenCV 窗口会打开，实时显示深度图像。图像中心会有一个绿色矩形框标记出ROI（感兴趣区域）。窗口左上角会显示当前ROI区域内深度值的中位数（经过初步转换为毫米）。
3.  **核心操作循环：**
    *   **a. 摆放与测量：** 将相机对准平整表面（如墙壁）。使用测距工具**精确测量**相机某个固定参考点（例如镜头前缘）到该平面的**真实物理距离**。
    *   **b. 观察ROI深度：** 观察OpenCV窗口中显示的 "ROI Median Depth"。确保这个值看起来与你当前设置的距离大致相关，并且ROI区域稳定地覆盖在平面上。
    *   **c. 终端输入：** 在**终端**中，脚本会提示：
        ```
        已采集 X 点。当前ROI报告中位深度: YYY.Ymm. 
        请输入真实距离(mm), 或 's'保存退出, 'q'不保存退出: 
        ```
        根据你步骤 `a` 中测量的**真实物理距离**（单位毫米），在终端输入该数值，然后按 **Enter**。
    *   **d. 数据记录：** 如果输入有效且当前帧的ROI深度也有效，脚本会将 `(你输入的真实距离, OpenCV窗口显示的ROI中位深度)` 记录下来，并增量保存到你指定的 `--output_file` JSON 文件中。终端会显示 "数据点已添加..."。
    *   **e. 重复：** 改变相机与平面之间的距离，重复步骤 `a` 到 `d`。
        *   **建议采集至少10-15个数据点，覆盖你常用的深度测量范围** (例如，从脚本中 `MIN_DEPTH_MM` 到 `MAX_DEPTH_MM` 的范围，可以每隔100mm或200mm采集一个点)。
        *   确保数据点在整个测量范围内都有分布，不要都集中在一个小区间。
4.  **结束采集：**
    *   当你在终端提示输入时，输入 `s` 然后按 Enter：脚本会提示你为当前OpenCV窗口显示的ROI深度值输入最后一个对应的真实距离，保存后程序退出。
    *   当你在终端提示输入时，输入 `q` 然后按 Enter：程序直接退出，不保存当前可能正在处理的数据点（但之前已记录并增量保存的点不受影响）。
    *   在OpenCV窗口激活时按键盘上的 'q'：脚本会尝试跳过当前终端的输入提示，并刷新到下一帧。这主要用于在终端等待输入时，如果你想看看相机的新画面。

### 注意事项

*   **测量精度：** 真实物理距离的测量精度对校准结果至关重要。
*   **平面质量：** 确保目标平面尽可能平整且垂直于相机的大致视线方向（尤其是在近距离时）。
*   **ROI区域：** 确保ROI区域完全落在目标平面上，并且该区域的深度值稳定。
*   **相机预热：** 某些深度相机可能需要几分钟的预热时间才能达到稳定的深度输出。
*   **数据文件：** 采集的数据会保存在一个JSON文件中，例如 `[{"true_mm": 300.0, "reported_mm_roi_median": 305.2}, {"true_mm": 500.0, "reported_mm_roi_median": 515.8}, ...]`。

---

## 第2步：分析数据并拟合校正模型 (`analyze_and_fit_depth_correction.py`)

此脚本加载上一步采集到的数据，拟合一个校正模型（线性或二次多项式），可视化拟合结果，并保存模型参数。

### 准备工作

1.  **数据文件：** 确保你已经通过 `collect_depth_calibration_data.py` 生成了包含深度数据点的JSON文件（例如 `my_16bit_depth_data.json`）。
2.  **软件准备：**
    *   Python 3 环境。
    *   必要的 Python 库：`numpy`, `matplotlib`, `scipy`。可以通过 `pip install numpy matplotlib scipy` 安装。
    *   `analyze_and_fit_depth_correction.py` 脚本文件。

### 运行脚本

1.  打开终端。
2.  使用 `cd` 命令导航到 `analyze_and_fit_depth_correction.py` 脚本所在的文件夹。
3.  执行以下命令（根据你的情况修改参数）：

    ```bash
    python analyze_and_fit_depth_correction.py --input_file <data_file.json> --model_type <model> --output_params_file <params_file.json>
    ```

    **参数说明：**

    *   `--input_file <data_file.json>`: **(必需)** 指向你在第1步中生成的包含深度数据对的JSON文件名。
    *   `--model_type <model>`: (可选) 指定拟合的校正模型类型。
        *   `linear` (默认): 拟合线性模型 `Z_corrected = a * Z_reported + b`。
        *   `quadratic`: 拟合二次多项式模型 `Z_corrected = a * Z_reported^2 + b * Z_reported + c`。
    *   `--output_params_file <params_file.json>`: (可选) 指定保存拟合出的模型参数的JSON文件名。默认为 `depth_correction_params.json`。建议根据模型类型和数据来源命名，例如 `linear_correction_16bit.json`。

    **示例命令：**

    *   为16位数据拟合线性模型：
        ```bash
        python analyze_and_fit_depth_correction.py --input_file my_16bit_depth_data.json --model_type linear --output_params_file linear_correction_16bit.json
        ```
    *   为16位数据拟合二次模型：
        ```bash
        python analyze_and_fit_depth_correction.py --input_file my_16bit_depth_data.json --model_type quadratic --output_params_file quadratic_correction_16bit.json
        ```

### 预期输出与结果

1.  **终端输出：**
    *   加载的数据点数量。
    *   拟合得到的模型参数（例如，对于线性模型，是 `a` 和 `b` 的值）。
    *   拟合模型的均方根误差 (RMSE) 和最大绝对误差（单位mm）。**RMSE越小，表示模型拟合得越好。**
2.  **Matplotlib 图表窗口：**
    *   会弹出一个图表，显示：
        *   **蓝色散点：** 你采集的原始数据点 (真实距离 vs. 相机报告的ROI中位深度)。
        *   **红色虚线：** 拟合出的校正模型曲线。
        *   **绿色点线：** 理想情况下的 `y=x` 线 (真实距离 = 报告距离)。
    *   **观察图表：**
        *   红色拟合曲线是否能很好地穿过蓝色数据点？
        *   与绿色的理想线相比，原始数据（蓝色点）和拟合后的数据（红色线）的偏差有多大？
        *   如果数据点明显呈非线性趋势，二次模型（如果选择）的红色曲线是否比线性模型更好地捕捉了这种趋势？
    *   关闭此图表窗口后，脚本会继续执行参数保存。
3.  **参数JSON文件：**
    *   脚本会将拟合出的模型类型、参数值和RMSE保存到你指定的 `--output_params_file` JSON文件中。这个文件将在你的主应用程序（如 `detect_table2.py`）中被加载和使用。

### 选择模型

*   通常先尝试**线性模型**。如果RMSE已经很小（例如几毫米到一厘米左右，取决于你的精度需求），并且图表显示线性拟合良好，那么线性模型可能就足够了。
*   如果线性模型的RMSE较大，或者图表显示数据点有明显的非线性趋势，再尝试**二次模型**，看看是否能显著降低RMSE并更好地拟合数据。
*   避免使用过于复杂的模型来拟合少量或噪声大的数据，因为这容易导致过拟合。

